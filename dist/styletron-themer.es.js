import _merge from 'lodash/merge';
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { injectStylePrefixed } from 'styletron-utils';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};









var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var _class;
var _temp;

var unnamedCounter = 0;

var Styled = (_temp = _class = function (_Component) {
  inherits(Styled, _Component);

  // we pull context from above
  function Styled(props, context) {
    classCallCheck(this, Styled);

    var _this = possibleConstructorReturn(this, (Styled.__proto__ || Object.getPrototypeOf(Styled)).call(this, props, context));

    if (!context.themeProvider) {
      // TODO: throw or console.error
    }

    _this.componentName = props.name;

    // ensure that the component's default styles are inserted into the master theme.
    // unnamed components are not installed into the theme
    //
    if (_this.componentName) context.themeProvider.installComponent(props.name, props.staticStyle);else _this.componentName = 'Unnamd_' + unnamedCounter++; // guaranteed to not be a legit component name in the theme
    return _this;
  }

  // this is where the magic happens. here we figure out what styles need to be applied
  // to this instance of the component. returns an object of styletron attributes (not classes)
  //


  /*
   every styled component can take two props which allow you to override
   the styles generated by the component directly:
    * className => if the user of a component passes a className prop explicitly,
   it is prepended to the list of styletron classes. use this to link to
   hard-coded classes in an external CSS file (e.g., "margined" or "select-multi")
    * style => the user can pass in a styletron object to override specific styles.
   this overloads React's "style" prop. it integrates with the styletron system,
   so the result of passing a style prop will actually be additional classes,
   not an inline style attribute
  */


  createClass(Styled, [{
    key: 'getStyle',
    value: function getStyle() {
      var // the theme is stored on context. this is our default theme, plus the user's overrides
      masterTheme = this.context.themeProvider.theme,


      // the theme for this component only. the fallback was used when we didn't require
      // a ThemeProvider as an ancestor, and should not be needed any more
      componentTheme = masterTheme[this.componentName] || this.props.staticStyle,


      // if the user doesn't give us a dynamic styling function, use the default styles
      styleObj = componentTheme;

      // use the component's dynamic styling function to adjust the styles for this instance
      // based on props
      //
      if (typeof this.props.dynamicStyle === 'function') {
        styleObj = this.props.dynamicStyle({

          // the base theme for this component
          componentTheme: componentTheme,

          // the global meta (for colors and other global attributes)
          globalMeta: masterTheme.meta,

          // last, but not least, the props
          props: this.props
        });
      }

      // all components accept a "style" prop for custom styletron attributes.
      // this overrides React's use of "style", as described above.
      //
      styleObj = _merge({}, styleObj, this.props.style);

      // lastly, middleware
      return this.context.themeProvider.applyMiddleware(styleObj);
    }
  }, {
    key: 'render',
    value: function render() {
      var styleProperties = this.getStyle(),
          _props = this.props,
          className = _props.className,
          children = _props.children,
          otherProps = objectWithoutProperties(_props, ['className', 'children']),
          name = otherProps.name,
          staticStyle = otherProps.staticStyle,
          dynamicStyle = otherProps.dynamicStyle,
          style = otherProps.style,
          passThroughProps = objectWithoutProperties(otherProps, ['name', 'staticStyle', 'dynamicStyle', 'style']),
          _context = this.context,
          styletron = _context.styletron,
          theme = _context.themeProvider.theme,
          styletronClasses = injectStylePrefixed(styletron, styleProperties);

      // invoke the render callback with two params
      return children(

      // see above for comments on the use of the className prop for legacy CSS classes
      (className ? className + ' ' : '') + styletronClasses, {
        // the base theme of your component
        componentTheme: theme[this.componentName],

        // the global meta (for colors, etc)
        globalMeta: theme.meta,

        // give the children access to all props except those consumed here. useful for
        // components that use render callbacks or have other prop-manipulations between
        // the original element and the children (ohai React.cloneElement)
        props: passThroughProps,

        // TODO: deprecated. to be removed.
        passThrough: passThroughProps
      });
    }
  }]);
  return Styled;
}(Component), _class.contextTypes = {

  // from StyletronProvider (see styletron-react)
  styletron: PropTypes.object.isRequired,

  // from ThemeProvider
  themeProvider: PropTypes.shape({
    theme: PropTypes.object.isRequired,
    installComponent: PropTypes.func.isRequired,
    applyMiddleware: PropTypes.func.isRequired
  })
}, _class.propTypes = {
  name: PropTypes.string, // unnamed components are not themeable; useful for one-offs
  staticStyle: PropTypes.object,
  dynamicStyle: PropTypes.func,
  className: PropTypes.string,
  style: PropTypes.object,
  children: PropTypes.func.isRequired
}, _temp);

function getDisplayName(Component$$1) {
  return Component$$1.displayName || Component$$1.name || (typeof Component$$1 === 'string' ? Component$$1 : 'Component');
}

function isObject(item) {
  return (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === "object" && !Array.isArray(item) && item !== null;
}

/**
 * the classify decorator is used by APPLICATION authors more than component authors.
 * it provides a "classify" function as a prop. this can be used to put styles
 * directly into HTML elements or other components that were not created with <Styled>
 *
 * @example
 *| @classify
 *| class MyComponent extends Component {
 *|    render() {
 *|      return <h2 className={this.props.classify({color: 'red'})}>Red title</h2>
 *|    }
 *| }
 */

// decorator. this is preferred over the HoC below.
// example above.
//
var classify = classifyComponent;
// standard HoC:
//  class MyComponent {...}
//  export classifyComponent(MyComponent)
//
function classifyComponent(CustomComponent) {
  var _class, _temp2;

  var ClassifiedComponent = (_temp2 = _class = function (_Component) {
    inherits(ClassifiedComponent, _Component);

    function ClassifiedComponent() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, ClassifiedComponent);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ClassifiedComponent.__proto__ || Object.getPrototypeOf(ClassifiedComponent)).call.apply(_ref, [this].concat(args))), _this), _this.classifyStyles = function () {
        for (var _len2 = arguments.length, styletronObjects = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          styletronObjects[_key2] = arguments[_key2];
        }

        var allStyles = _merge.apply(undefined, [{}].concat(styletronObjects)),
            themeProvider = _this.context.themeProvider;

        if (themeProvider) allStyles = themeProvider.applyMiddleware(allStyles);
        return injectStylePrefixed(_this.context.styletron, allStyles);
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    // we pull context from above


    createClass(ClassifiedComponent, [{
      key: 'render',
      value: function render() {
        return React.createElement(CustomComponent, _extends({}, this.props, {
          classify: this.classifyStyles
        }));
      }
    }]);
    return ClassifiedComponent;
  }(Component), _class.contextTypes = {

    // from StyletronProvider (see styletron-react)
    styletron: PropTypes.object.isRequired,

    // from ThemeProvider
    themeProvider: PropTypes.shape({
      applyMiddleware: PropTypes.func.isRequired
    })
  }, _class.displayName = 'Classify_' + getDisplayName(CustomComponent), _temp2);

  return ClassifiedComponent;
}

var baseTheme = {

  // the default styles for each component are in the component's `styles.js` file.
  // meta can have whatever you like.
  //
  meta: {
    colors: {
      // functional colors
      primary: '#00c653',

      // simply named colors
      gray0: '#000',
      gray6: '#666f74',
      grayE: '#e4eaed'
    },

    // other shared constants
    hover: {
      transitionSpeed: '150ms'
    }
  }
};

var libraryMeta = {};

function installLibraryMeta(t) {
  libraryMeta = t;
}

function getDefaultTheme() {
  return _merge({}, baseTheme, { meta: libraryMeta });
}

/*
  this module doesn't provide generic tools for middleware management.
  it simply provides a single middleware tool for color mapping.
*/

var fullTextSearch = ['background', 'border', 'borderColor', 'outline'];
var svgAttributes = ['stroke', 'fill'];

function isKeyColorRelated(key) {

  // we need to trap both "color" and "Color" in the attribute name. so we just
  // look for "olor", which is a safe search (i.e., there are no false positives)
  //
  if (key.indexOf('olor') > -1) return true;

  // a few custom attributes that don't have "color" in their names
  //
  return svgAttributes.concat(fullTextSearch).indexOf(key) !== -1;
}

function valueMapper(theme, key, value) {
  // if the value is a simple match for an existing color, use it
  var outputColor = theme.meta.colors[value];
  if (outputColor) return outputColor;

  // for shorthand properties ("background"), we have to do a full text search & replace
  if (fullTextSearch.indexOf(key) > -1) {
    var anyChanges = false;
    outputColor = value;

    Object.keys(theme.meta.colors).forEach(function (oneColor) {

      var re = new RegExp('\\b' + oneColor + '\\b');

      outputColor = outputColor.replace(re, function () {
        anyChanges = true;
        return theme.meta.colors[oneColor];
      });
    });
    if (anyChanges) return outputColor;
  }
}

// the heavy lifting is done here. this function doesn't know anything about
// colors; the callbacks make this very reusable
//
function styleDive(theme, styles, keyTester, valueMapper) {

  var clonedRoot = false,
      cloneNow = function cloneNow() {
    if (!clonedRoot) styles = _merge({}, styles);
    clonedRoot = true;
  };

  Object.keys(styles).forEach(function (key) {

    if (isObject(styles[key])) {
      var _styleDive = styleDive(theme, styles[key], keyTester, valueMapper),
          clonedChild = _styleDive.cloned,
          childStyles = _styleDive.styles;

      if (clonedChild) cloneNow();
      styles[key] = childStyles;
    } else if (keyTester(key)) {

      var originalValue = styles[key],
          mappedValue = valueMapper(key, originalValue);

      if (mappedValue !== undefined) {
        cloneNow();
        styles[key] = mappedValue;
      }
    }
  });

  return {
    styles: styles,
    cloned: clonedRoot
  };
}

// a convenience function that does key-based lookups into the global meta.
// if you use a key like "primary" or "blueGray" in any color-related style
// attribute, it will be converted to a CSS string. otherwise, your input is
// returned untouched.
//
function mapColorKeys(theme, styles) {
  return styleDive(theme, styles, isKeyColorRelated, valueMapper.bind(null, theme)).styles;
}

var availableMiddlewares = Object.freeze({
	mapColorKeys: mapColorKeys
});

var _class$1;
var _temp$1;

/**
 * Main wrapper component to enable theming of UI components.
 */
var ThemeProvider = (_temp$1 = _class$1 = function (_Component) {
  inherits(ThemeProvider, _Component);
  createClass(ThemeProvider, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        themeProvider: {
          theme: this.theme,
          middlewares: this.middlewares,
          installComponent: this.installComponent,
          applyMiddleware: this.applyMiddleware
        }
      };
    }

    // pass these down on context

  }]);

  function ThemeProvider(props, context) {
    classCallCheck(this, ThemeProvider);

    // do a deep merge with the library theme and the user's overrides. theming is
    // a one-shot deal; we do not currently support dynamic themes, although that
    // would be easy to add in the future.
    //
    var _this = possibleConstructorReturn(this, (ThemeProvider.__proto__ || Object.getPrototypeOf(ThemeProvider)).call(this, props, context));

    _this.installComponent = function (componentName, componentTheme) {
      if (_this.installedComponents.indexOf(componentName) === -1) {
        _this.theme[componentName] = _merge({}, componentTheme, _this.theme[componentName]);
        _this.installedComponents.push(componentName);
      }
    };

    _this.applyMiddleware = function (styleObj) {
      return _this.middlewares.reduce(function (styleObj, mw) {
        return mw(_this.theme, styleObj);
      }, styleObj);
    };

    _this.theme = _merge({}, getDefaultTheme(), props.theme);
    _this.middlewares = props.middlewares || [mapColorKeys];
    _this.installedComponents = [];
    return _this;
  }

  // each styled component will be added to the master theme, with a key that
  // matches its name:
  //    fullTheme = {meta:{}, Button:{}, Icon:{} ... }
  //


  createClass(ThemeProvider, [{
    key: 'render',


    // TODO: add a componentWillReceiveProps hook, which will allow the user to
    // change the theme on the fly

    value: function render() {
      return React.Children.only(this.props.children);
    }
  }]);
  return ThemeProvider;
}(Component), _class$1.childContextTypes = {
  themeProvider: PropTypes.shape({
    theme: PropTypes.object.isRequired,
    middlewares: PropTypes.array,
    installComponent: PropTypes.func,
    applyMiddleware: PropTypes.func
  })
}, _temp$1);

ThemeProvider.propTypes = {
  theme: PropTypes.object,
  middlewares: PropTypes.array
};

// provided as a convenient export for consumers. it is not
// used directly by this component.
//
ThemeProvider.middlewares = availableMiddlewares;

export { Styled, classify, ThemeProvider, classifyComponent, installLibraryMeta };
